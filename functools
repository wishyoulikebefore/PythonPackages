functools 用于增强函数功能

functools.partial(func, *args, **keywords)
#创建偏函数：调用partial对象和调用被修饰的函数func相同，适用于某次使用只需要更改部分参数的情况。
#partial对象就可以将这些不变的对象冻结起来
def take(n, iterable):
    """Return first *n* items of the iterable as a list.
        >>> take(3, range(10))
        [0, 1, 2]
    """
    return list(itertools.islice(iterable, n))

def chunked(iterable, n):
    """Break *iterable* into lists of length *n*:
        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))
        [[1, 2, 3], [4, 5, 6]]
        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))
        [[1, 2, 3], [4, 5, 6], [7, 8]]
    """
    return iter(functools.partial(take, n, iter(iterable)), [])  #iter(callable, sentinel)

iter(callable, sentinel) 会持续调用参数callable直至其返回sentinel
因此会使得iter(iterable)不断进行直至抛出错误(黑科技)

wraps
#使用装饰器修饰后的函数会丢失元信息（如名字、文档字符串、注解和参数签名），导致在多进程中不可被pickle
当wraps充当其装饰器时，可以避免这个问题
from functools import wraps     
def my_decorator(func):  
    @wraps
    def wrapper(*args, **kwargs):  
        print('Calling decorated function...')  
        return func(*args, **kwargs)  
    return wrapper    
 





