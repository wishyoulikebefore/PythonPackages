Array creation routines
empty(shape)：创建新数组，只分配内存空间但不填充任何值
eye(N)和identity(N)：创建一个N*N的单位矩阵
>>>np.eye(3)                     
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
ones()：1矩阵
>>>np.ones((3,4))               
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]]
zeros()：0矩阵
>>>np.zeros((3,4))               
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]

full(shape,fill_value)：以给定shape创建数组，填充fill_value
>>> np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])

array()
asarray()：将输入转化为array
asmatrix()
copy()：对数组进行复制
tolist()：将np数据返回为python形式的list
tostring()
frombuffer(buffer)
fromfile(file)
fromfunction()
fromiter(iterable)
fromstring()
loadtxt()
arange()：等同于range

linspace(start,end,num,endpoint=True)     构建等差数列
>>> np.linspace(1,3,9)
[ 1.    1.25  1.5   1.75  2.    2.25  2.5   2.75  3.  ]
>>> np.linspace(1,3,9,endpoint=False)     #endpoint参数指定是否包含终值
array([ 1.        ,  1.22222222,  1.44444444,  1.66666667,  1.88888889,
        2.11111111,  2.33333333,  2.55555556,  2.77777778])
logspace(start, stop, num, endpoint=True, base=10.0)   构建等比数列
>>> np.logspace(0,2,5)        #起始值0表示100，终止值2表示102
array([ 1. ,    3.16227766,   10.        ,   31.6227766 ,  100.        ])
>>> np.logspace(0,2,5,base=2)
array([ 1.        ,  1.41421356,  2.        ,  2.82842712,  4.        ])

geomspace()
meshgrid()

diag()
diagflat()
tri()
tril()
triu()
vander()

mat(data)
bmat()

Array manipulation routines
copyto()：Copies values from one array to another
reshape(a, newshape)

ravel()：定形与重塑，多维数据转化为一维数组
#ravel()不会产生源数据的副本
>>> x = np.arange(12).reshape(3,4)
>>> x.ravel()
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> x.ravel().tolist()
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
#ravel()可以添加参数，指定行和列的优先顺序（C和Fortran顺序）
>>> x.ravel("F")
array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])

flatten()和ravel()类似，但是返回数据的副本

moveaxis(a,source,destination)
rollaxis(a,axis)
swapaxes()
transpose()

broadcast()
broadcast_to(array,shape)：Broadcast any number of arrays against each other
expand_dims(a,axis)
squeeze()：Remove single-dimensional entries from the shape of an array

require()：Return an ndarray of the provided type that satisfies requirements

concatenate()

stack()：array的重堆积
>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.stack((a, b))
array([[1, 2, 3],
       [2, 3, 4]])
>>> np.stack((a, b), axis=-1)
array([[1, 2],
       [2, 3],
       [3, 4]])

hstack()：Stack arrays in sequence horizontally (column wise)
vstack()：Stack arrays in sequence vertically (row wise)
block()

tile(A,reps) ：重复填充A reps次
>>>np.tile(inX,(dataSetSize,1))-dataSet

repeat(a,repeats,axis=None)
#axis:默认使用flattern array形式
>>> np.repeat(3, 4)
array([3, 3, 3, 3])
>>> x = np.array([[1,2],[3,4]])
>>> np.repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
>>> np.repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])

delete(arr,obj[,axis])

insert(arr,obj,values)：Insert values along the given axis before the given indices
>>> a = np.array([[1, 1], [2, 2], [3, 3]])
>>> np.insert(a, 1, 5)
array([1, 5, 1, 2, 2, 3, 3])
>>> np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])
>>> np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])

append(arr,values)：Append values to the end of an array
resize(a,new_shape)
trim_zeros()：Trim the leading and/or trailing zeros from a 1-D array or sequence

unique()：Find the unique elements of an array
intersect1d(x,y)：交集
union1d(x,y)：并集
setdiff1d(x,y)：存在于x但不存于y
setxor1d(x,y)：存在于一个数组中但不同时存在于两个数组中
in1d(x,y)：测试一个数组中的值在另一个数组中的成员资格
>>> values=np.array([6,0,0,3,2,5,6])
>>> np.in1d(values,[2,3,6])
array([ True, False, False,  True,  True, False,  True], dtype=bool)

flip(m,axis)：Reverse the order of elements in an array along the given axis
fliplr()：Flip array in the left/right direction
flipud()
reshape()
roll()

String operations
#vectorized string operations for array of type numpy.string_. 全部方法都是基于python标准库
mod(a,values)：Return (a % i)
center(a)：Return a copy of a with its elements centered in a string of length width
join()
ljust()
swapcase()：大小写互换
translate(a,table[,deletechars])：
zfill(a,width)：字符左边填充0

equal(x1,x2)
not_equal()
greater_equal()
less_equal()
greater()
less()
Datetime Support Functions
busdaycalendar
is_busday
busday_offset(dates,offsets)
busday_count(begindates,enddates)

Functional programming
apply_along_axis()
apply_over_axes()
vectorize()：将输入参数为标量的函数转变为输入参数为数组的函数
>>> def myfunc(a, b):
...     if a > b:
...         return a - b
...     else:
...         return a + b
>>> vfunc = np.vectorize(myfunc)
>>> vfunc([1, 2, 3, 4], 2)
array([3, 4, 1, 2])


frompyfunc(function, shape, **kwargs)
>>> def func(i,j):
	return (i+1)*(j+1)             #i,j为索引位置
>>> np.fromfunction(func,(9,9))
array([[  1.,   2.,   3.,   4.,   5.,   6.,   7.,   8.,   9.],
       	[  2.,   4.,   6.,   8.,  10.,  12.,  14.,  16.,  18.],
       	[  3.,   6.,   9.,  12.,  15.,  18.,  21.,  24.,  27.],
       	[  4.,   8.,  12.,  16.,  20.,  24.,  28.,  32.,  36.],
       	[  5.,  10.,  15.,  20.,  25.,  30.,  35.,  40.,  45.],
       	[  6.,  12.,  18.,  24.,  30.,  36.,  42.,  48.,  54.],
       	[  7.,  14.,  21.,  28.,  35.,  42.,  49.,  56.,  63.],
       	[  8.,  16.,  24.,  32.,  40.,  48.,  56.,  64.,  72.],
      	[  9.,  18.,  27.,  36.,  45.,  54.,  63.,  72.,  81.]])

piecewise()

Indexing routines
nonzero()：返回非0元素的索引
>>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])
>>> np.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2], dtype=int64))

where(condition,[x,y])：只给出条件，返回为真的元素索引；否则对应返回x或者y
>>> x = np.arange(9).reshape(3, 3)
>>> np.where(x>5)
(array([2, 2, 2], dtype=int64), array([0, 1, 2], dtype=int64))
>>> x[np.where( x > 5 )]               # Note: result is 1D.
array([6, 7, 8])
>>> np.where(x < 5, x, -1)
array([[ 0,  1,  2],
       [ 3,  4, -1],
       [-1, -1, -1]])

>>>df = pd.DataFrame({'Type':list('ABBC'), 'Set':list('ZZXY')})
>>>df['color'] = np.where(df['Set']=='Z', 'green', 'red')
Set Type  color
0   Z    A  green
1   Z    B  green
2   X    B    red
3   Y    C    red

indices(dimensions)：Return an array representing the indices of a grid

ix_()：整合不同数组，用于选取方形区域
#进行广播时，不需先reshape
>>> arr=np.arange(32).reshape(8,4)
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
>>> arr[[1,5,7,2],[0,3,1,2]]
array([ 4, 23, 29, 10])
#选出元素(1,0) (5,3) (7,1) (2,2)
>>> arr[[1,5,7,2]][:,[0,3,1,2]]
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
>>> arr[np.ix_([1,5,7,2],[0,3,1,2])]
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
[ 8, 11,  9, 10]])
>>> a = np.array([2,3,4,5])
>>> b = np.array([8,5,4])
>>> ax,bx = np.ix_(a,b)
>>> ax*bx
array([[16, 10,  8],
       [24, 15, 12],
       [32, 20, 16],
       [40, 25, 20]])

ravel_multi_index()
unravel_index()

take()

choose(a, choices, out=None, mode='raise')
np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])
#mode : {'raise' (default), 'wrap', 'clip'}, optional
        Specifies how indices outside `[0, n-1]` will be treated:
    	'raise' : an exception is raised
        'wrap' : value becomes value mod `n`
        'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1
>>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
>>> choices = [-10, 10]
>>> np.choose(a, choices)
array([[ 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10]])
>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
    ...   [20, 21, 22, 23], [30, 31, 32, 33]]
>>> np.choose([2, 3, 1, 0], choices
... # the first element of the result will be the first element of the
... # third (2+1) "array" in choices, namely, 20; the second element
... # will be the second element of the fourth (3+1) choice array, i.e.,
... # 31, etc.
... )
array([20, 31, 12,  3])
>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
array([20, 31, 12,  3])
>>> # because there are 4 choice arrays
>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
array([20,  1, 12,  3])

compress()
diag()

select(condlist, choicelist, default=0)
# Return an array drawn from elements in choicelist, depending on conditions
>>> x = np.arange(10)
>>> condlist = [x<3, x>5]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist)
array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])

split(array, indices_or_sections, axis=0)
# indices_or_sections :数字或者1维数组（数字：等分；一维数组：指定分割处）
>>> x = np.arange(9.0)
>>> np.split(x,3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]
>>> np.split(x, [3, 5, 6, 10])
[array([ 0.,  1.,  2.]), array([ 3.,  4.]), array([ 5.]), array([ 6.,  7.,  8.]), array([], dtype=float64)]

place()
put()
putmask()
fill_diagonal()

Sorting,searching and counting
sort
lexsort(keys)：Perform an indirect sort using a sequence of keys
argsort(a, axis=-1, kind='quicksort', order=None)：返回array排序的索引
>>> x = np.array([[0, 3], [2, 2]])
>>> np.argsort(x, axis=0)
array([[0, 1],
       [1, 0]], dtype=int64)

msort：Return a copy of an array sorted along the first axis
partition
argpartition

argmax
nanargmax
argmin
nanargmin
argwhere
nonzero
flatnonzero
searchsorted

extract(condition, arr)
>>> arr = np.arange(12).reshape((3, 4))
>>> condition = np.mod(arr, 3)==0
>>> condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]], dtype=bool)
>>> np.extract(condition, arr)
array([0, 3, 6, 9])
Test Support
assert_almost_equal
assert_equal
assert_raises
assert_string_equal

Mathematical 
average(a, axis=None, weights=None, returned=False)
>>> data = np.arange(6).reshape((3,2))
>>> np.average(data, axis=1, weights=[1./4, 3./4])
array([ 0.75,  2.75,  4.75])

cumprod: Return the cumulative product of elements along a given axis
cumsum: Return the cumulative sum of the elements along a given axis.
cumsum(a, axis=None, dtype=None, out=None)
>>> a = np.array([[1,2,3], [4,5,6]])
>>> np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21], dtype=int32)
>>> np.cumsum(a,axis=0)
array([[1, 2, 3],
       [5, 7, 9]], dtype=int32)

nansum：视NaNs为0
nancumsum：视NaNs为0
nancumprod：视NaNs为1

delete(arr, obj, axis=None)
#如果axis为None，则输出为flattened array
>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])
>>> np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])

dot(a, b, out=None)
乘法操作符 * 表示的也是元素乘法；矩阵乘法使用dot函数
>>> A = np.array( [[1,1],  
...             [0,1]] )  
>>> B = np.array( [[2,0],  
...             [3,4]] )  
>>> A*B                         # 各元素相乘 
array([[2, 0],  
      [0, 4]])  
>>> np.dot(A,B)                  # dot表示矩阵乘法  
array([[5, 4],  
       [3, 4]])  

divide(x1,x2)
true_divide(x1,x2)
floor_divide(x1,x2)
power(x1,x2)：x1**x2
remainder(x1,x2)或mod(x1,x2)：x1%x2
negative(x)

meshgrid(x,y)：接受两个一维数组，返回两个二维矩阵（对应两个数组中所有(x,y)对）
#适于网格型数据
>>> points = np.arange(-3,3)
>>> xs,ys = np.meshgrid(points,points)
>>> xs
array([[-3, -2, -1,  0,  1,  2],
       [-3, -2, -1,  0,  1,  2],
       [-3, -2, -1,  0,  1,  2],
       [-3, -2, -1,  0,  1,  2],
       [-3, -2, -1,  0,  1,  2],
       [-3, -2, -1,  0,  1,  2]])
>>> ys
array([[-3, -3, -3, -3, -3, -3],
       [-2, -2, -2, -2, -2, -2],
       [-1, -1, -1, -1, -1, -1],
       [ 0,  0,  0,  0,  0,  0],
       [ 1,  1,  1,  1,  1,  1],
       [ 2,  2,  2,  2,  2,  2]])
