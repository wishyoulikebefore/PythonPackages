numpy的数组类型为 ndarray， ndarray 的重要属性包括: 
ndarray.ndim：数组的维数，也称为rank
ndarray.shape：数组各维的大小tuple 类型，对一个n 行m 列的矩阵来说， shape 为 (n,m)
ndarray.size：元素的总数。 
ndarray.dtype：每个元素的类型，可以是 numpy.int32, numpy.int16, and numpy.float64 等
ndarray.itemsize：每个元素占用的字节数
ndarray.data：指向数据内存

数组：不需使用循环即可对数据进行批量运算（矢量化）

当将一个标量值赋值给一个切片（arr[5:8]=12），会“广播”到整个选区。与列表最重要的区别：数组切片为原始数组的视图，不会被复制，任何修改都会直接反映到源数组上（由于Numpy设计目的是处理大数据，坚持复制会影响性能和内存），如果需要得到副本，使用copy()指令。

多维数组的存取
 
广播
不同形状的数组之间的算术运算的执行方式
原则：如果两个数组的后缘维度（从末尾开始算的维度）的轴长度相等或其中一方的长度为1，则认为是广播兼容的。广播会在缺失或长度为1的维度上进行
多维数组的加法
1）	让所有输入数组都向其中维数最多的数组看齐，shape属性中不足的部分在前面加1补齐
2）	输出数组的shape属性是输入数组shape属性在各个轴上的最大值
3）	输入数组的某个轴长度为1或与输出数组对应轴长度相同，方能使用；否则出错
4）	当输入数组的某个轴长度为1时，沿着此轴运算时都用此轴的第一组值
 
In [102]: arr1 = np.arange(3)
In [103]: arr2 = np.arange(3).reshape(-1,1)
In [104]: arr2
Out[104]: 
array([[0],
       [1],
       [2]])
In [105]: arr1+arr2
Out[105]: 
array([[0, 1, 2],
       [1, 2, 3],
[2, 3, 4]])
In [106]: arr = np.random.randn(4,3)
In [107]: arr.mean()
Out[107]: -0.31722275316370857
In [108]: arr.mean(0)
Out[108]: array([-0.61683694,  0.46381026, -0.79864158])
In [109]: demeaned = arr - arr.mean(0)

通过索引机制插入轴的特殊语法：np.newaxis
#处理三维数组，对轴2进行距平化

In [112]: arr = np.random.randn(3,4,5)
In [113]: depth_means = arr.mean(2)
In [114]: depth_means
Out[114]: 
array([[ 0.58365367,  0.35191244, -0.17505078,  0.11554989],
       [ 0.08309521, -0.01929041, -0.41087692,  0.45031759],
       [-0.25629441, -0.44083317, -0.00343687,  0.09742973]])
In [115]: demeaned = arr - depth_means[:,:,np.newaxis]
In [116]: demeaned.mean(2)

Bool索引
>>> names = np.array(["Bob","Joe","Will","Bob","Will","Joe","Joe"])
>>> data  = np.random.randn(7,4)
>>> data[names=="Bob",2:]
array([[ 0.57909519, -0.75951999],
[-0.98737198,  0.37472686]])
>>> data[data<0] = 0
>>> data
array([[ 0.12720438,  0.        ,  0.57909519,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ],
       [ 1.02128742,  0.        ,  1.3756622 ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.37472686],
       [ 0.        ,  0.5815817 ,  0.54935048,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  1.38219453],
[ 0.53436621,  1.19203767,  0.        ,  0.        ]])

数组重塑
reshape(a, newshape)
#作为参数形状的其中一维可以是-1，表示该纬度的大小由数据本身推断而来
In [2]: np.arange(15).reshape(5,-1)
Out[2]: 
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
[12, 13, 14]])

ravel()：定形与重塑，多维数据转化为一维数组
#ravel()不会产生源数据的副本
>>> x = np.arange(12).reshape(3,4)
>>> x.ravel()
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> x.ravel().tolist()
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
#ravel()可以添加参数，指定行和列的优先顺序（C和Fortran顺序）
>>> x.ravel("F")
array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])

flatten()和ravel()类似，但是返回数据的副本

数组的合并
concatenate((a1, a2, ...), axis=0)
In [6]: arr1 = np.array([[1,2,3],[4,5,6]])
In [7]: arr2 = np.array([[7,8,9],[10,11,12]])

In [8]: np.concatenate([arr1,arr2],axis=0)
Out[8]: 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
[10, 11, 12]])
In [9]: np.concatenate([arr1,arr2],axis=1)
Out[9]: 
array([[ 1,  2,  3,  7,  8,  9],
[ 4,  5,  6, 10, 11, 12]])

简便的方法：hstack()  vstack()
hstack()：Stack arrays in sequence horizontally (column wise)
vstack()：Stack arrays in sequence vertically (row wise)

In [28]: np.vstack([arr1,arr2])
Out[28]: 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
In [29]: np.hstack([arr1,arr2])
Out[29]: 
array([[ 1,  2,  3,  7,  8,  9],
[ 4,  5,  6, 10, 11, 12]])

堆叠辅助类：r_和c_ (堆叠到row和column)
In [34]: arr = np.arange(6)
In [35]: arr1 = arr.reshape(3,2)
In [36]: arr2 = randn(3,2)

In [40]: np.r_[arr1,arr2]
Out[40]: 
array([[ 0.        ,  1.        ],
       [ 2.        ,  3.        ],
       [ 4.        ,  5.        ],
       [-1.23054809,  0.41675661],
       [-0.91655721, -1.3014227 ],
[ 0.58487572,  1.59903336]])
In [42]: np.c_[np.r_[arr1,arr2],arr]
Out[42]: 
array([[ 0.        ,  1.        ,  0.        ],
       [ 2.        ,  3.        ,  1.        ],
       [ 4.        ,  5.        ,  2.        ],
       [-1.23054809,  0.41675661,  3.        ],
       [-0.91655721, -1.3014227 ,  4.        ],
[ 0.58487572,  1.59903336,  5.        ]])

#可以将切片翻译为数组
In [43]: np.c_[1:6,-10:-5]
Out[43]: 
array([[  1, -10],
       [  2,  -9],
       [  3,  -8],
       [  4,  -7],
[  5,  -6]])



数组的拆分
split(ary, indices_or_sections, axis=0)
# indices_or_sections :数字或者1维数组（数字：等分；一维数组：指定分割处）

In [32]: np.split(arr,3)
Out[32]: [array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]
In [33]: np.split(arr,[2,4,6])
Out[33]: [array([0, 1]), array([2, 3]), array([4, 5]), array([6, 7, 8])]

split的便捷化函数：hsplit, vsplit, dsplit (分别沿轴0，轴1，轴2)

元素的重复操作
repeat(a, repeats, axis=None)
#repeats：int(重复次数) array of int（每个元素的重复次数）
#axis：默认扁平化

In [50]: arr = np.random.randn(2,2)
In [52]: arr.repeat(2)
Out[52]: 
array([-1.0615055 , -1.0615055 , -0.48882242, -0.48882242, -0.08670415,
       -0.08670415,  0.26666297,  0.26666297])
In [54]: arr.repeat(2,axis=0)
Out[54]: 
array([[-1.0615055 , -0.48882242],
       [-1.0615055 , -0.48882242],
       [-0.08670415,  0.26666297],
       [-0.08670415,  0.26666297]])
In [56]: arr.repeat(2,axis=1)
Out[56]: 
array([[-1.0615055 , -1.0615055 , -0.48882242, -0.48882242],
[-0.08670415, -0.08670415,  0.26666297,  0.26666297]])
In [57]: arr.repeat([1,2],axis=1)
Out[57]: 
array([[-1.0615055 , -0.48882242, -0.48882242],
[-0.08670415,  0.26666297,  0.26666297]])

tile(A,reps) ：沿指定轴向堆叠数组副本，重复填充A reps次

In [59]: np.tile(arr,2)
Out[59]: 
array([[-1.0615055 , -0.48882242, -1.0615055 , -0.48882242],
[-0.08670415,  0.26666297, -0.08670415,  0.26666297]])
In [61]: np.tile(arr,[3,2])
Out[61]: 
array([[-1.0615055 , -0.48882242, -1.0615055 , -0.48882242],
       [-0.08670415,  0.26666297, -0.08670415,  0.26666297],
       [-1.0615055 , -0.48882242, -1.0615055 , -0.48882242],
       [-0.08670415,  0.26666297, -0.08670415,  0.26666297],
       [-1.0615055 , -0.48882242, -1.0615055 , -0.48882242],
[-0.08670415,  0.26666297, -0.08670415,  0.26666297]])

花式索引的等价函数
take(a, indices, axis=None, out=None, mode='raise')
put(a, ind, v, mode='raise')
#v：放置在ind的v值，会取代原有数值

In [67]: arr = np.arange(10)*100
In [68]: inds = [7,1,2,6]
In [69]: arr.take(inds)
Out[69]: array([700, 100, 200, 600])
In [70]: arr.put(inds,42)
In [71]: arr
Out[71]: array([  0,  42,  42, 300, 400, 500,  42,  42, 800, 900])
In [72]: arr.put(inds,[40,41,42,43])
In [73]: arr
Out[73]: array([  0,  41,  42, 300, 400, 500,  43,  40, 800, 900])

In [74]: inds = [2,0,2,1]
In [77]: arr = np.random.randn(2,4)
In [79]: arr.take(inds,axis=1)
Out[79]: 
array([[-1.06076315, -0.90428546, -1.06076315,  0.3850614 ],
[-0.03719946, -0.00328381, -0.03719946,  0.4122919 ]])


排序
sort(a, axis=-1, kind='quicksort', order=None)
In [123]: arr = np.random.randn(2,4)
In [124]: arr
Out[124]: 
array([[-0.31076558,  0.72276449, -1.14582013,  1.25311544],
       [ 1.55856152,  0.91621145, -0.54612114,  0.1392782 ]])
In [125]: arr[:,0].sort()      #只对第一列排序
In [127]: arr.sort(axis=0)
In [128]: arr
Out[128]: 
array([[-0.31076558,  0.72276449, -1.14582013,  0.1392782 ],
       [ 1.55856152,  0.91621145, -0.54612114,  1.25311544]])
In [129]: arr.sort(axis=1)
In [130]: arr
Out[130]: 
array([[-1.14582013, -0.31076558,  0.1392782 ,  0.72276449],
       [-0.54612114,  0.91621145,  1.25311544,  1.55856152]])
#无法选择降序，只能通过values[::-1]

argsort(a, axis=-1, kind='quicksort', order=None)
#返回array排序的索引
In [132]: values = np.array([5,0,1,3,2])
In [133]: indexer = values.argsort()
In [134]: indexer
Out[134]: array([1, 2, 4, 3, 0])
In [135]: values[indexer]
Out[135]: array([0, 1, 2, 3, 5])
#根据数组的第一行进行排序
In [132]: values = np.array([5,0,1,3,2])
In [133]: indexer = values.argsort()
In [134]: indexer
Out[134]: array([1, 2, 4, 3, 0])
In [135]: values[indexer]
Out[135]: array([0, 1, 2, 3, 5])
In [136]: arr = np.random.randn(3,5)
In [137]: arr[0] = values
In [138]: arr
Out[138]: 
array([[ 5.        ,  0.        ,  1.        ,  3.        ,  2.        ],
       [ 0.1736755 ,  1.31535662,  0.48170524, -2.37890838, -0.87069844],
       [ 0.10919081,  0.84268432,  1.62716829,  0.05610142,  1.06205833]])
In [139]: arr[:,arr[0].argsort()]
Out[139]: 
array([[ 0.        ,  1.        ,  2.        ,  3.        ,  5.        ],
       [ 1.31535662,  0.48170524, -0.87069844, -2.37890838,  0.1736755 ],
[ 0.84268432,  1.62716829,  1.06205833,  0.05610142,  0.10919081]])

lexsort(keys, axis=-1)
#可以一次性对多个键数组进行间接排序，优先级为从后往前

In [141]: first_name = np.array(["Bob","Jane","Steve","Bill","Barbara"])
In [142]: last_name = np.array(["Jones","Arnold","Arnold","Jones","Walters"])
In [143]: sorter = np.lexsort((first_name,last_name))
In [144]: zip(last_name[sorter],first_name[sorter])
searchsorted(a, v, side='left', sorter=None)
#在有序数组中查找元素，插值后不影响数组的有序性
In [147]: arr = np.array([0,1,7,12,15])
In [148]: arr
Out[148]: array([ 0,  1,  7, 12, 15])
In [149]: arr.searchsorted(9)
Out[149]: 3
In [150]: arr.searchsorted([0,8,11,16])
Out[150]: array([0, 3, 3, 5])
#可利用进行数据拆分
In [161]: data = np.floor(np.random.uniform(0,10000,size=50))
In [162]: data
Out[162]: 
array([ 6489.,  9360.,  2166.,  1647.,  4565.,  2929.,  7843.,  1956.,
        2651.,   510.,  9763.,  2561.,  9844.,  9488.,    89.,  2592.,
         937.,  2209.,  5736.,  1770.,  3784.,  2154.,  3093.,  7064.,
         513.,  8328.,   726.,  6463.,  7451.,  7654.,  3430.,  5742.,
         871.,  4200.,  1389.,   623.,  5871.,  6669.,  2885.,  7162.,
        5072.,  5490.,  7981.,   104.,  2202.,  4266.,  5154.,  8539.,
         934.,  9165.])
In [163]: bins = np.array([0,100,1000,5000,10000])
In [164]: labels = bins.searchsorted(data)
In [165]: labels
Out[165]: 
array([4, 4, 3, 3, 3, 3, 4, 3, 3, 2, 4, 3, 4, 4, 1, 3, 2, 3, 4, 3, 3, 3, 3,
       4, 2, 4, 2, 4, 4, 4, 3, 4, 2, 3, 3, 2, 4, 4, 3, 4, 4, 4, 4, 2, 3, 3,
       4, 4, 2, 4])
In [166]: Series(data).groupby(labels).mean()
Out[166]: 
1      89.000000
2     652.250000
3    2760.473684
4    7378.545455


